Modern encryption techniques: Digital data is represented in strings of binary digits (bits) unlike alphabets. Modern cryptosystems need to process this binary strings to convert in to another binary string. Based on how these binary strings are processed, a symmetric encryption schemes can be classified in to Block Ciphers In this scheme, the plain binary text is processed in blocks (groups) of bits at a time; i.e. a block of plaintext bits is selected, a series of operations is performed on this block to generate a block of ciphertext bits. The number of bits in a block is fixed. For example, the schemes DES and AES have block sizes of 64 and 128, respectively. Stream Ciphers In this scheme, the plaintext is processed one bit at a time i.e. one bit of plaintext is taken, and a series of operations is performed on it to generate one bit of ciphertext. Technically, stream ciphers are block ciphers with a block size of one bit. Block Cipher The basic scheme of a block cipher is depicted as follows  A block cipher takes a block of plaintext bits and generates a block of ciphertext bits, generally of same size. The size of block is fixed in the given scheme. The choice of block size does not directly affect to the strength of encryption scheme. The strength of cipher depends up on the key length. Block Size Though any size of block is acceptable, following aspects are borne in mind while selecting a size of a block.
Avoid very small block size  Say a block size is m bits. Then the possible plaintext bits combinations are then 2m. If the attacker discovers the plain text blocks corresponding to some previously sent ciphertext blocks, then the attacker can launch a type of dictionary attack by building up a dictionary of plaintext/ciphertext pairs sent using that encryption key. A larger block size makes attack harder as the dictionary needs to be larger.  Do not have very large block size  With very large block size, the cipher becomes inefficient to operate. Such plaintexts will need to be padded before being encrypted.  Multiples of 8 bit  A preferred block size is a multiple of 8 as it is easy for implementation as most computer processor handle data in multiple of 8 bits. Padding in Block Cipher Block ciphers process blocks of fixed sizes (say 64 bits). The length of plaintexts is mostly not a multiple of the block size. For example, a 150  bit plaintext provides two blocks of 64 bits each with third block of balance 22 bits. The last block of bits needs to be padded up with redundant information so that the length of the final block equal to block size of the scheme. In our example, the remaining 22 bits need to have additional 42 redundant bits added to provide a complete block. The process of adding bits to the last block is referred to as padding. Too much padding makes the system inefficient. Also, padding may render the system insecure at times, if the padding is done with same bits always. Block Cipher Schemes There is a vast number of block ciphers schemes that are in use. Many of them are publically known. Most popular and prominent block ciphers are listed below.  Digital Encryption Standard (DES)  The popular block cipher of the 1990s. It is now considered as a _broken_ block cipher, due primarily to its small key size.  Triple DES  It is a variant scheme based on repeated DES applications. It is still a respected block ciphers but inefficient compared to the new faster block ciphers available.  Advanced Encryption Standard (AES)  It is a relatively new block cipher based on the encryption algorithm Rijndael that won the AES design competition.  IDEA  It is a sufficiently strong block cipher with a block size of 64 and a key size of 128 bits. A number of applications use IDEA encryption, including early versions of Pretty Good Privacy (PGP) protocol. The use of IDEA scheme has a restricted adoption due to patent issues. Feistel Block Cipher: Feistel Cipher is not a specific scheme of block cipher. It is a design model from which many different block ciphers are derived. DES is just one example of a Feistel Cipher. A cryptographic system based on Feistel cipher structure uses the same algorithm for both encryption and decryption. Encryption Process The encryption process uses the Feistel structure consisting multiple rounds of processing of the plaintext, each round consisting of a "substitution" step followed by a permutation step. Feistel Structure is shown in the following illustration
The input block to each round is divided into two halves that can be denoted as L and R for the left half and the right half.  In each round, the right half of the block, R, goes through unchanged. But the left half, L, goes through an operation that depends on R and the encryption key. First, we apply an encrypting function _f_ that takes two input  the key K and R. The function produces the output f(R,K). Then, we XOR the output of the mathematical function with L.  In real implementation of the Feistel Cipher, such as DES, instead of using the whole encryption key during each round, a round  dependent key (a subkey) is derived from the encryption key. This means that each round uses a different key, although all these subkeys are related to the original key.  The permutation step at the end of each round swaps the modified L and unmodified R. Therefore, the L for the next round would be R of the current round. And R for the next round be the output L of the current round.  Above substitution and permutation steps form a _round_. The number of rounds are specified by the algorithm design.  Once the last round is completed then the two sub blocks, _R_ and _L_ are concatenated in this order to form the ciphertext block. The difficult part of designing a Feistel Cipher is selection of round function _f_. In order to be unbreakable scheme, this function needs to have several important properties that are beyond the scope of our discussion. Decryption Process The process of decryption in Feistel cipher is almost similar. Instead of starting with a block of plaintext, the ciphertext block is fed into the start of the Feistel structure and then the process thereafter is exactly the same as described in the given illustration. The process is said to be almost similar and not exactly same. In the case of decryption, the only difference is that the subkeys used in encryption are used in the reverse order. The final swapping of _L_ and _R_ in last step of the Feistel Cipher is essential. If these are not swapped then the resulting ciphertext could not be decrypted using the same algorithm. Number of Rounds The number of rounds used in a Feistel Cipher depends on desired security from the system. More number of rounds provide more secure system. But at the same time, more rounds mean
the inefficient slow encryption and decryption processes. Number of rounds in the systems thus depend upon efficiency  security tradeoff. The Data Encryption Standard (DES) is a symmetric  key block cipher published by the National Institute of Standards and Technology (NIST). DES is an implementation of a Feistel Cipher. It uses 16 round Feistel structure. The block size is 64  bit. Though, key length is 64  bit, DES has an effective key length of 56 bits, since 8 of the 64 bits of the key are not used by the encryption algorithm (function as check bits only). General Structure of DES is depicted in the following illustration  Since DES is based on the Feistel Cipher, all that is required to specify DES is   Round function  Key schedule  Any additional processing  Initial and final permutation Initial and Final Permutation The initial and final permutations are straight Permutation boxes (P  boxes) that are inverses of each other. They have no cryptography significance in DES. The initial and final permutations are shown as follows

Round Function The heart of this cipher is the DES function, f. The DES function applies a 48  bit key to the rightmost 32 bits to produce a 32  bit output.  Expansion Permutation Box  Since right input is 32  bit and round key is a 48  bit, we first need to expand right input to 48 bits. Permutation logic is graphically depicted in the following illustration   The graphically depicted permutation logic is generally described as table in DES specification illustrated as shown
Key Generation The round  key generator creates sixteen 48  bit keys out of a 56  bit cipher key. The process of key generation is depicted in the following illustration  The logic for Parity drop, shifting, and Compression P  box is given in the DES description. DES Analysis The DES satisfies both the desired properties of block cipher. These two properties make cipher very strong.  Avalanche effect  A small change in plaintext results in the very grate change in the ciphertext.  Completeness  Each bit of ciphertext depends on many bits of plaintext. During the last few years, cryptanalysis have found some weaknesses in DES when key selected are weak keys. These keys shall be avoided. DES has proved to be a very well designed block cipher. There have been no significant cryptanalytic attacks on DES other than exhaustive key search.
3  KEY Triple DES Before using 3TDES, user first generate and distribute a 3TDES key K, which consists of three different DES keys K 1 , K 2 and K 3 . This means that the actual 3TDES key has length 356 = 168 bits. The encryption scheme is illustrated as follows  The encryption  decryption process is as follows   Encrypt the plaintext blocks using single DES with key K 1 .  Now decrypt the output of step 1 using single DES with key K 2 .  Finally, encrypt the output of step 2 using single DES with key K 3 .  The output of step 3 is the ciphertext.  Decryption of a ciphertext is a reverse process. User first decrypt using K 3, then encrypt with K 2, and finally decrypt with K 1 . Due to this design of Triple DES as an encrypt  decrypt  encrypt process, it is possible to use a 3TDES (hardware) implementation for single DES by setting K 1, K2, and K 3 to be the same value. This provides backwards compatibility with DES. Second variant of Triple DES (2TDES) is identical to 3TDES except that K 3 is replaced by K 1 . In other words, user encrypt plaintext blocks with key K 1, then decrypt with key K 2, and finally encrypt with K 1 again. Therefore, 2TDES has a key length of 112 bits. Triple DES systems are significantly more secure than single DES, but these are clearly a much slower process than encryption using single DES. Advanced Encryption Standard The more popular and widely adopted symmetric encryption algorithm likely to be encountered nowadays is the Advanced Encryption Standard (AES). It is found at least six time faster than triple DES. A replacement for DES was needed as its key size was too small. With increasing computing power, it was considered vulnerable against exhaustive key search attack. Triple DES was designed to overcome this drawback but it was found slow.
The features of AES are as follows   Symmetric key symmetric block cipher  128  bit data, 128/192/256  bit keys  Stronger and faster than Triple  DES  Provide full specification and design details  Software implementable in C and Java Operation of AES AES is an iterative rather than Feistel cipher. It is based on _substitution  permutation network_. It comprises of a series of linked operations, some of which involve replacing inputs by specific outputs (substitutions) and others involve shuffling bits around (permutations). Interestingly, AES performs all its computations on bytes rather than bits. Hence, AES treats the 128 bits of a plaintext block as 16 bytes. These 16 bytes are arranged in four columns and four rows for processing as a matrix  Unlike DES, the number of rounds in AES is variable and depends on the length of the key. AES uses 10 rounds for 128  bit keys, 12 rounds for 192  bit keys and 14 rounds for 256  bit keys. Each of these rounds uses a different 128  bit round key, which is calculated from the original AES key. The schematic of AES structure is given in the following illustration  Encryption Process Here, we restrict to description of a typical round of AES encryption. Each round comprise of four sub  processes. The first round process is depicted below
